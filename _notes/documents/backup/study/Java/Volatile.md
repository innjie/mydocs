## volatile
자바 코드의 변수를 메인 메모리에 저장할 것을 명시하기 위해 사용한다. 모든 volatile 변수는 컴퓨터 메인 메모리로부터 읽히고, 쓰기 작업 또한 메인 메모리로 직접 이루어진다. 따라서 CPU 캐시를 사용하지 않는다. volatile 사용해서 가시성을 보장한다.

### 가시성 보장
volatile 키워드가 없다면 멀티 스레드 환경에서 자원에 접근할 때 변수가 언제 cpu 캐시에서 메모리로 쓰일 지 보장할 수 없다. 즉, 캐시와 메모리 상의 변수가 서로 다른 값이 될 수 있는 것이다. 이처럼 다른 스레드가 변경한 값을 볼 수 없는 상태를 `가시성` 이라고 한다.

> 정리
`volatile` 키워드를 사용하면 메인 메모리에서 직접 쓰기 때문에 일관성이 보장된다.

### 단점
#### 경쟁 상태
멀티스레드 환경에서 volatile 공유 변수의 값이 이전 값에 의존하지 않는다면 메모리의 값을 읽고 쓸 때 정확한 값을 사용할 수 있다. 그러나 만약, 스레드가 volatile의 새 값을 위해 초기 값 및 이전 값을 필요로 한다면 문제가 발생한다. 새 값을 생성하고, 덮어씌울 수 있는 것이다. 여러 스레드가 한 공유 변수에 접근하여 변수 값을 변경하고, 스레드 내 캐시에 저장하여 메인 메모리에 적절한 값으로 업데이트가 되지 않는 경우에 해당한다.

#### 성능 저하
`volatile` 변수 특성 상 메인 메모리를 사용하여 Read / Write 작업을 수행한다. 이 작업은 CPU의 캐시를 사용하는 것보다 많은 비용이 필요하다. 따라서, `volatile`의 사용은 변수의 가시성 보장이 반드시 필요한 경우에만 사용해야 한다.

### 사용?
여러 스레드가 동시에 Read / Write를 한다면 공유 변수의 `원자성`을 보장하기 위해 `synchronized` 키워드를 함께 사용해야 한다. `synchronized`를 대체하기 위해서는 `AtomicLong`, `AtomicReference`를 사용할 수 있다.

한 공유 변수에 대해서 한개의 스레드만 Read / Write를 하고, 나머지 스레드들은 Read만 한다면 `volatile` 사용이 유효하다. Read를 처리하는 스레드들은 항상 최신의 volatile 변수값을 사용하며, 변수의 원자성도 보장할 수 있다.




출처
[volitile 개요](https://parkcheolu.tistory.com/16)
[Java Volatile Keyword](https://jenkov.com/tutorials/java-concurrency/volatile.html)

